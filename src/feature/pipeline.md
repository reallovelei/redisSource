## 管道 pipeline

管道其实并不是 redis 的特性，而是系统提供的一种减少网络请求次数的方式。通过将多个网络请求合并成一个，而提升 I/O。

以 php 为例，我们看一下 php 使用 pipeline 方式是怎么请求 redis 的。
```php
$redis = new Redis();
$redis->connect('localhost',6379);
$pipe = $redis->multi(Redis::PIPELINE);

for($i= 0 ; $i< 10000 ; $i++) {
    // do something
}
$replies = $pipe->exec();
```

我们在 redis 服务端开启 monotor，查看一下接收到的命令
```
1552361503.506252 [0 127.0.0.1:46046] "SET" "key0" "0"
1552361503.506263 [0 127.0.0.1:46046] "SET" "key1" "1"
1552361503.506267 [0 127.0.0.1:46046] "SET" "key2" "2"
1552361503.506269 [0 127.0.0.1:46046] "SET" "key3" "3"
1552361503.506287 [0 127.0.0.1:46046] "SET" "key4" "4"
1552361503.506288 [0 127.0.0.1:46046] "SET" "key5" "5"
1552361503.506290 [0 127.0.0.1:46046] "SET" "key6" "6"
1552361503.506292 [0 127.0.0.1:46046] "SET" "key7" "7"
1552361503.506294 [0 127.0.0.1:46046] "SET" "key8" "8"
1552361503.506295 [0 127.0.0.1:46046] "SET" "key9" "9"
```

可以发现，从 redis 服务器的角度来说，收到的命令和普通模式并没有什么区别。真正的区别在于 php 扩展在 pipeline 的模式下，是通过**一次网络请求**发送了 10 条命令，而非 pipeline 模式下，会通过 **10 次网络请求**来完成。

> 当然，也不是开启了 pipeline 都是只用一次网络请求，还要根据缓冲区大小而定，pipeline 的目的是通过减少网络请求的方式来提高 I/O。